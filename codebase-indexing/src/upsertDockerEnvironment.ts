import { getRerankerModelSnapshotDir, getEmbeddingModelSnapshotDir, getHfCacheDir } from "./hfCache.ts";
import { runCommand } from "./runner.ts";

declare const process: any;

async function readEnvFile(filePath: string): Promise<Map<string, string>> {
  const envMap = new Map<string, string>();
  
  const readResult = await runCommand(`[ -f "${filePath}" ] && cat "${filePath}"`);
  if (readResult.exitCode !== 0 || !readResult.stdout.trim()) {
    return envMap;
  }
  
  const lines = readResult.stdout.split('\n');
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }
    
    const equalIndex = trimmed.indexOf('=');
    if (equalIndex > 0) {
      const key = trimmed.substring(0, equalIndex).trim();
      const value = trimmed.substring(equalIndex + 1).trim();
      envMap.set(key, value);
    }
  }
  
  return envMap;
}

async function writeEnvFile(filePath: string, envMap: Map<string, string>): Promise<void> {
  const lines: string[] = [
    `# Docker environment variables`,
    `# Generated by upsertDockerEnvironment.ts on ${new Date().toISOString()}`,
    ``
  ];
  
  for (const [key, value] of envMap.entries()) {
    lines.push(`${key}=${value}`);
  }
  lines.push('');
  
  const content = lines.join('\n');
  
  const writeResult = await runCommand(`cat > "${filePath}" << 'EOF'\n${content}EOF`);
  if (writeResult.exitCode !== 0) {
    throw new Error(`Failed to write .env file: ${writeResult.stderr}`);
  }
}

export async function upsertDockerEnvironment(envFilePath: string = "./.env"): Promise<void> {
    const upsertEnvMap = {
        "HF_CACHE_DIR": `${(await getHfCacheDir()).split('/hub').shift()}`,
        "TEI_BASE_URL": "http://embedding-model:8000",
        "RERANKER_MODEL_PATH": `/data/hub${(await getRerankerModelSnapshotDir()).split('/hub').pop()}`,
        "EMBEDDING_MODEL_PATH": `/data/hub${(await getEmbeddingModelSnapshotDir()).split('/hub').pop()}`
    }

    console.log(`\nUpserting Docker environment variables to ${envFilePath}:`);

    const existingEnv = await readEnvFile(envFilePath);
    
    let updatedCount = 0;
    let skippedCount = 0;
    
    for (const [key, value] of Object.entries(upsertEnvMap)) {
      if (existingEnv.has(key)) {
        console.log(`  ${key} present.`);
        skippedCount++;
      } else {
        existingEnv.set(key, value);
        console.log(`  Added ${key}=${value}`);
        updatedCount++;
      }
    }
    
    if (updatedCount > 0) {
      if (process.env.TEST_MODE) {
        console.log(`\n  Test mode: Skipping write to .env file`);
        return;
      }
      await writeEnvFile(envFilePath, existingEnv);
      console.log(`\nUpdated .env file with ${updatedCount} new variable(s)`);
    } else {
      console.log(`\nNo updates needed. All variables already exist.`);
    }
}
